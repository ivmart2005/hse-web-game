–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Background\Background.tsx
================================================================================
import { useCollisionSystem, useGameLoop } from '../../hooks';
import { useGame } from '../../contexts/GameContext';
import { ASSET_PATHS } from '../../constants';
import type { Position } from '../../types';
import './Background.css';

const Background: React.FC = () => {
  const { gameState, setGameState } = useGame();
  const { checkCollision, isLoaded } = useCollisionSystem();

  const handleGameUpdate = (newPosition: Position, _velocity: { x: number; y: number }, isMoving: boolean) => {
    setGameState(prev => ({
      ...prev,
      position: newPosition,
      isWalking: isMoving
    }));
  };

  useGameLoop({
    keys: gameState.keys,
    onUpdate: handleGameUpdate,
    checkCollision: isLoaded ? checkCollision : () => false
  });

  return (
    <img
      src={ASSET_PATHS.BACKGROUND}
      alt="game background"
      className="background-image"
      style={{
        top: gameState.position.y,
        left: gameState.position.x
      }}
    />
  );
};

export default Background;
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Background\index.ts
================================================================================
export { default } from './Background.tsx';
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Character\Character.tsx
================================================================================
// components/Character/Character.tsx
import React, { useRef, useEffect } from 'react'; // ‚Üê –î–û–ë–ê–í–¨ –≠–¢–£ –°–¢–†–û–ö–£
import { useKeyboardControls } from '../../hooks';
import { useGame } from '../../contexts/GameContext';
import { useSpriteManager } from '../../hooks/useSpriteManager';
import { useAnimation } from '../../hooks';
import { GAME_CONFIG } from '../../constants';
import './Character.css';

const Character: React.FC = () => {
  const { direction } = useKeyboardControls();
  const { gameState } = useGame();
  const { currentFrame } = useAnimation(gameState.isWalking);
  const { loaded, loadingProgress, getStaticSprite, getWalkSprite } = useSpriteManager();

  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    if (!loaded || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const sprite = gameState.isWalking 
      ? getWalkSprite(currentFrame)
      : getStaticSprite();

    if (sprite) {
      ctx.drawImage(sprite, 0, 0, canvas.width, canvas.height);
    }
  }, [loaded, gameState.isWalking, currentFrame, getStaticSprite, getWalkSprite]);

  if (!loaded) {
    return (
      <div className="character-loading">
        Loading sprites: {Math.round(loadingProgress)}%
      </div>
    );
  }

  return (
    <div className="character-container">
      <div className="character-shadow" />
      <canvas
        ref={canvasRef}
        width={GAME_CONFIG.CHARACTER.WIDTH}
        height={GAME_CONFIG.CHARACTER.HEIGHT}
        className={`character ${direction === 'left' ? 'character-facing-left' : 'character-facing-right'}`}
      />
    </div>
  );
};

export default Character;
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Character\index.ts
================================================================================
export { default } from './Character.tsx';
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Game\Game.tsx
================================================================================
import React, { useState } from 'react';
import { useGameScale, useKeyboardControls, useCollisionSystem, useAnimation, useCamera, useGameLoop } from '../../hooks';
import { GAME_CONFIG, ASSET_PATHS } from '../../constants';
import type { Position } from '../../types';
import './Game.css';

const Game: React.FC = () => {
  const [position, setPosition] = useState<Position>({
    x: GAME_CONFIG.BACKGROUND.INITIAL_X,
    y: GAME_CONFIG.BACKGROUND.INITIAL_Y
  });
  const [isWalking, setIsWalking] = useState(false);

  const { scale, containerRef } = useGameScale();
  const { keys, direction } = useKeyboardControls();
  const { checkCollision, isLoaded } = useCollisionSystem();
  const { currentFrame } = useAnimation(isWalking);
  const { zoom, updateCamera } = useCamera();

  const handleGameUpdate = (newPosition: Position, velocity: { x: number; y: number }, isMoving: boolean) => {
    setPosition(newPosition);
    setIsWalking(isMoving);
    updateCamera(velocity);
  };

  useGameLoop({
    keys,
    onUpdate: handleGameUpdate,
    checkCollision: isLoaded ? checkCollision : () => false
  });

  const getCurrentImage = () => {
    if (!isWalking) {
      return ASSET_PATHS.CHARACTER.STATIC;
    }
    return ASSET_PATHS.CHARACTER.FRAME(currentFrame);
  };

  const combinedScale = scale * zoom;

  return (
    <div ref={containerRef} className="game-container">
      <div 
        className="game-world"
        style={{
          width: `${GAME_CONFIG.WIDTH}px`,
          height: `${GAME_CONFIG.HEIGHT}px`,
          transform: `scale(${combinedScale})`
        }}
      >
        {/* —Ñ–æ–Ω */}
        <img
          src={ASSET_PATHS.BACKGROUND}
          alt="game background"
          className="background-image"
          style={{
            top: position.y,
            left: position.x
          }}
        />
        {/* –ø–µ—Ä—Å–æ–Ω–∞–∂ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π –∏ —Ç–µ–Ω—å—é */}
        <div className="character-container">
          {/* —Ç–µ–Ω—å */}
          <div className="character-shadow" />
          {/* –ø–µ—Ä—Å–æ–Ω–∞–∂ */}
          <img
            src={getCurrentImage()}
            alt="character"
            className={`character ${direction === 'left' ? 'character-facing-left' : 'character-facing-right'}`}
            style={{
              width: `${GAME_CONFIG.CHARACTER.WIDTH}px`,
              height: `${GAME_CONFIG.CHARACTER.HEIGHT}px`
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default Game;
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Game\index.ts
================================================================================
export { default } from './Game';
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Game-–£—Å—Ç–∞—Ä–µ–≤—à–∏–π.tsx
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import './Game.css';

interface Keys {
  w: boolean;
  a: boolean;
  s: boolean;
  d: boolean;
}

interface Velocity {
  x: number;
  y: number;
}

// —Ö—É–∫ –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –º–∞—Å—à—Ç–∞–±–∞
const useGameScale = (gameWidth: number, gameHeight: number) => {
  const [scale, setScale] = useState(1);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const updateScale = () => {
      if (containerRef.current) {
        const container = containerRef.current;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        
        if (containerWidth > 0 && containerHeight > 0 && gameWidth > 0 && gameHeight > 0) {
          const scaleX = containerWidth / gameWidth;
          const scaleY = containerHeight / gameHeight;
          const newScale = Math.min(scaleX, scaleY);
          
          setScale(newScale);
        }
      }
    };
    updateScale();
    window.addEventListener('resize', updateScale);
    
    return () => window.removeEventListener('resize', updateScale);
  }, []);

  return { scale, containerRef };
};

const Game: React.FC = () => {
  const [position, setPosition] = useState({ x: -180, y: -250 });
  const [currentFrame, setCurrentFrame] = useState(0);
  const [isWalking, setIsWalking] = useState(false);
  const [facingDirection, setFacingDirection] = useState<'right' | 'left'>('right');
  const [cameraZoom, setCameraZoom] = useState(1);

  // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏–≥—Ä—ã
  const acceleration = 0.15;
  const deceleration = 0.1;
  const maxSpeed = 5;
  const baseZoom = 1;
  const maxZoom = 1.2;
  const zoomSpeed = 0.002;
  const frames = [1, 2, 3, 4, 5, 6, 10];
  const GAME_WIDTH = 1600;
  const GAME_HEIGHT = 600;
  const characterWidth = 280;
  const characterHeight = 460;

  const keys = useRef<Keys>({ w: false, a: false, s: false, d: false });
  const velocity = useRef<Velocity>({ x: 0, y: 0 });
  const animationFrameId = useRef<number | null>(null);
  const walkAnimationTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const gameLoopRunning = useRef(false);

  // –ú–∞—Å–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
  const collisionCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const collisionContextRef = useRef<CanvasRenderingContext2D | null>(null);
  const maskImageRef = useRef<HTMLImageElement | null>(null);
  const maskLoadedRef = useRef(false);
  const backgroundSizeRef = useRef({ width: 0, height: 0 });

  const { scale, containerRef } = useGameScale(GAME_WIDTH, GAME_HEIGHT);

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
  const checkCollision = (x: number, y: number): boolean => {
    if (!collisionContextRef.current || !maskLoadedRef.current) {
      return false;
    }

    try {
      const maskWidth = collisionCanvasRef.current?.width || 0;
      const maskHeight = collisionCanvasRef.current?.height || 0;
      const bgWidth = backgroundSizeRef.current.width;
      const bgHeight = backgroundSizeRef.current.height;
      
      if (maskWidth === 0 || maskHeight === 0 || bgWidth === 0 || bgHeight === 0) {
        return false;
      }
      
      const shadowCenterWorldX = GAME_WIDTH / 2;
      const shadowCenterWorldY = GAME_HEIGHT / 2 + characterHeight / 2 - 10;
      const bgX = shadowCenterWorldX - x;
      const bgY = shadowCenterWorldY - y;
      const scaleX = maskWidth / bgWidth;
      const scaleY = maskHeight / bgHeight;
      const maskX = Math.floor(bgX * scaleX);
      const maskY = Math.floor(bgY * scaleY);
      
      if (maskX >= 0 && maskX < maskWidth && maskY >= 0 && maskY < maskHeight) {
        const pixelData = collisionContextRef.current.getImageData(maskX, maskY, 1, 1).data;
        const [r, g, b] = pixelData;
        const isWhite = r === 255 && g === 255 && b === 255;
        return !isWhite;
      } else {
        return true;
      }
    } catch (error) {
      return false;
    }
  };

  useEffect(() => {
    const loadMask = () => {
      const maskImage = new Image();
      maskImageRef.current = maskImage;
      maskImage.onload = () => {
        const maskWidth = maskImage.naturalWidth;
        const maskHeight = maskImage.naturalHeight;
        const canvas = document.createElement('canvas');
        canvas.width = maskWidth;
        canvas.height = maskHeight;
        collisionCanvasRef.current = canvas;
        const context = canvas.getContext('2d');
        
        if (!context) return;
        
        collisionContextRef.current = context;
        collisionContextRef.current.drawImage(maskImage, 0, 0, maskWidth, maskHeight);
        maskLoadedRef.current = true;
      };
      maskImage.src = '/assets/images/background_mask.png';
    };

    const bgImage = new Image();
    bgImage.onload = () => {
      backgroundSizeRef.current = {
        width: bgImage.naturalWidth,
        height: bgImage.naturalHeight
      };
      loadMask();
    };
    bgImage.src = '/assets/images/background.png';
  }, []);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (['ArrowRight', 'ArrowLeft', 'ArrowDown', 'ArrowUp', 'd', 'a', 's', 'w', '–≤', '—ã', '—Ñ', '—Ü'].includes(event.key)) {
        event.preventDefault();
      }
      
      switch (event.key.toLowerCase()) {
        case 'arrowright':
        case 'd':
        case '–≤':
          keys.current.d = true;
          setFacingDirection('right');
          break;
        case 'arrowleft':
        case 'a':
        case '—Ñ':
          keys.current.a = true;
          setFacingDirection('left');
          break;
        case 'arrowdown':
        case 's':
        case '—ã':
          keys.current.s = true;
          keys.current.w = false;
          break;
        case 'arrowup':
        case 'w':
        case '—Ü':
          keys.current.w = true;
          keys.current.s = false;
          break;
        default:
          break;
      }
    };

    const handleKeyUp = (event: KeyboardEvent) => {
      switch (event.key.toLowerCase()) {
        case 'arrowright':
        case 'd':
        case '–≤':
          keys.current.d = false;
          break;
        case 'arrowleft':
        case 'a':
        case '—Ñ':
          keys.current.a = false;
          break;
        case 'arrowdown':
        case 's':
        case '—ã':
          keys.current.s = false;
          break;
        case 'arrowup':
        case 'w':
        case '—Ü':
          keys.current.w = false;
          break;
        default:
          break;
      }
    };

    const gameLoop = () => {
      if (!gameLoopRunning.current) return;
      
      setPosition(prev => {
        let targetVelocityX = 0;
        let targetVelocityY = 0;
        
        if (keys.current.d) targetVelocityX = -maxSpeed;
        if (keys.current.a) targetVelocityX = maxSpeed;
        if (keys.current.s) targetVelocityY = -maxSpeed;
        if (keys.current.w) targetVelocityY = maxSpeed;

        // –ü–ª–∞–≤–Ω–æ–µ —É—Å–∫–æ—Ä–µ–Ω–∏–µ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
        if (targetVelocityX !== 0) {
          if (Math.abs(velocity.current.x) < Math.abs(targetVelocityX)) {
            velocity.current.x += Math.sign(targetVelocityX) * acceleration;
          }
        } else {
          if (velocity.current.x > 0) {
            velocity.current.x = Math.max(0, velocity.current.x - deceleration);
          } else if (velocity.current.x < 0) {
            velocity.current.x = Math.min(0, velocity.current.x + deceleration);
          }
        }

        // –ü–ª–∞–≤–Ω–æ–µ —É—Å–∫–æ—Ä–µ–Ω–∏–µ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
        if (targetVelocityY !== 0) {
          if (Math.abs(velocity.current.y) < Math.abs(targetVelocityY)) {
            velocity.current.y += Math.sign(targetVelocityY) * acceleration;
          }
        } else {
          if (velocity.current.y > 0) {
            velocity.current.y = Math.max(0, velocity.current.y - deceleration);
          } else if (velocity.current.y < 0) {
            velocity.current.y = Math.min(0, velocity.current.y + deceleration);
          }
        }
        
        velocity.current.x = Math.max(-maxSpeed, Math.min(maxSpeed, velocity.current.x));
        velocity.current.y = Math.max(-maxSpeed, Math.min(maxSpeed, velocity.current.y));

        let newX = prev.x;
        let newY = prev.y;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
        if (velocity.current.x !== 0) {
          const step = Math.sign(velocity.current.x);
          let testX = prev.x;
          for (let i = 0; i < Math.abs(velocity.current.x); i++) {
            testX += step;
            if (checkCollision(testX, prev.y)) {
              testX -= step;
              velocity.current.x = 0;
              break;
            }
          }
          newX = testX;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
        if (velocity.current.y !== 0) {
          const step = Math.sign(velocity.current.y);
          let testY = prev.y;
          for (let i = 0; i < Math.abs(velocity.current.y); i++) {
            testY += step;
            if (checkCollision(newX, testY)) {
              testY -= step;
              velocity.current.y = 0;
              break;
            }
          }
          newY = testY;
        }

        const currentSpeed = Math.sqrt(velocity.current.x ** 2 + velocity.current.y ** 2);
        const targetZoom = baseZoom + (currentSpeed / maxSpeed) * (maxZoom - baseZoom);        
        setCameraZoom(prevZoom => {
          const zoomDiff = targetZoom - prevZoom;
          return prevZoom + zoomDiff * zoomSpeed;
        });
        
        const isMoving = Math.abs(velocity.current.x) > 0.1 || Math.abs(velocity.current.y) > 0.1;
        setIsWalking(isMoving);
        
        return { x: newX, y: newY };
      });
      
      animationFrameId.current = requestAnimationFrame(gameLoop);
    };

    gameLoopRunning.current = true;
    animationFrameId.current = requestAnimationFrame(gameLoop);
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      gameLoopRunning.current = false;
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
        animationFrameId.current = null;
      }
      
      if (walkAnimationTimer.current) {
        clearInterval(walkAnimationTimer.current);
        walkAnimationTimer.current = null;
      }
    };
  }, []);

  // –ê–Ω–∏–º–∞—Ü–∏—è —Ö–æ–¥—å–±—ã
  useEffect(() => {
    if (isWalking) {
      walkAnimationTimer.current = setInterval(() => {
        setCurrentFrame(prev => (prev + 1) % frames.length);
      }, 210);
    } else {
      setCurrentFrame(0);
    }

    return () => {
      if (walkAnimationTimer.current) {
        clearInterval(walkAnimationTimer.current);
        walkAnimationTimer.current = null;
      }
    };
  }, [isWalking]);

  const getCurrentImage = () => {
    if (!isWalking) {
      return `/assets/images/walk_animation/static.png`;
    }
    const frameIndex = frames[currentFrame];
    return `/assets/images/walk_animation/${frameIndex}.png`;
  };

  const combinedScale = scale * cameraZoom;

  return (
    <div ref={containerRef} className="game-container">
      <div 
        className="game-world"
        style={{
          width: `${GAME_WIDTH}px`,
          height: `${GAME_HEIGHT}px`,
          transform: `scale(${combinedScale})`
        }}
      >
        <img
          src="/assets/images/background.png"
          alt="game background"
          className="background-image"
          style={{
            top: position.y,
            left: position.x
          }}
        />

        <div className="character-container">
          <div className="character-shadow" />
          <img
            src={getCurrentImage()}
            alt="character"
            className={`character ${facingDirection === 'left' ? 'character-facing-left' : 'character-facing-right'}`}
            style={{
              width: `${characterWidth}px`,
              height: `${characterHeight}px`
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default Game;
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Objects\index.ts
================================================================================
export { default as InteractiveObject } from './InteractiveObject/InteractiveObject';
export { default as TalkingMouse } from './TalkingMouse/TalkingMouse';
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Objects\InteractiveObject\index.ts
================================================================================
export { default } from './InteractiveObject';
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Objects\InteractiveObject\InteractiveObject.tsx
================================================================================
import React from 'react';
import { useInteractiveObject } from '../../../hooks/objects/useInteractiveObject';
import { useGame } from '../../../contexts/GameContext';
import './InteractiveObject.css';

interface InteractiveObjectProps {
  id: string;
  type: string;
  position: { x: number; y: number };
  sprite: string;
  interactionRadius: number;
  onInteract: () => void;
  showHint?: boolean;
  hintText?: string;
  children?: React.ReactNode | ((isNear: boolean) => React.ReactNode);
}

export const InteractiveObject: React.FC<InteractiveObjectProps> = ({
  id,
  type,
  position,
  sprite,
  interactionRadius,
  onInteract,
  showHint = true,
  hintText = '–ù–∞–∂–º–∏ E',
  children
}) => {
  const { gameState } = useGame();
  const { isNear, canInteract } = useInteractiveObject({
    objectId: id,
    position,
    interactionRadius,
    onInteract
  });

  // –ö–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è —Ñ–æ–Ω–∞
  const objectScreenX = position.x + gameState.position.x;
  const objectScreenY = position.y + gameState.position.y;

  return (
    <div 
      className={`interactive-object interactive-object--${type}`}
      style={{ 
        position: 'absolute',
        left: objectScreenX,
        top: objectScreenY,
        transform: 'translate(-50%, -50%)'
      }}
    >
      <img 
        src={sprite} 
        alt={id} 
        className="interactive-object__sprite"
      />
      
      {/* –ü–æ–¥–¥–µ—Ä–∂–∫–∞ render prop */}
      {children && typeof children === 'function' ? children(isNear) : children}
      
      {isNear && showHint && canInteract && (
        <div className="interactive-object__hint">
          {hintText}
        </div>
      )}
    </div>
  );
};

export default InteractiveObject;
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Objects\TalkingMouse\index.ts
================================================================================
export { default } from './TalkingMouse';
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\components\Objects\TalkingMouse\TalkingMouse.tsx
================================================================================
import React from 'react';
import InteractiveObject from '../InteractiveObject/InteractiveObject';
import './TalkingMouse.css';

interface TalkingMouseProps {
  position?: { x: number; y: number };
  onTalk?: () => void;
}

export const TalkingMouse: React.FC<TalkingMouseProps> = ({ 
  position = { x: 300, y: 200 },
  onTalk = () => console.log("–ü–∏-–ø–∏! –Ø –≥–æ–≤–æ—Ä—è—â–∞—è –º—ã—à—å!")
}) => {
  return (
    <InteractiveObject
      id="talking_mouse_1"
      type="npc"
      position={position}
      sprite="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='50' height='50' viewBox='0 0 50 50'%3E%3Crect width='50' height='50' fill='%23ff6b6b' rx='10'/%3E%3Ctext x='25' y='30' text-anchor='middle' fill='white' font-size='20'%3Eüê≠%3C/text%3E%3C/svg%3E"
      interactionRadius={60}
      onInteract={onTalk}
      hintText="–ü–æ–≥–æ–≤–æ—Ä–∏—Ç—å —Å –º—ã—à—å—é"
    >
      {/* –¢–µ–ø–µ—Ä—å —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è, –∞ –Ω–µ JSX */}
      {(isNear: boolean) => (
        <div 
          className="mouse-debug-background"
          style={{
            position: 'absolute',
            top: '-30px',
            left: '-30px',
            width: '110px',
            height: '110px',
            backgroundColor: isNear ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.2)',
            border: `2px dashed ${isNear ? 'green' : 'red'}`,
            borderRadius: '8px',
            pointerEvents: 'none',
            zIndex: -1,
            transition: 'all 0.3s ease'
          }}
        />
      )}
    </InteractiveObject>
  );
};

export default TalkingMouse;
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\contexts\GameContext.tsx
================================================================================
import React, { createContext, useContext, useState } from 'react';
import type { ReactNode } from 'react';
import type { Position, Keys } from '../types';

interface GameState {
  position: Position;
  isWalking: boolean;
  keys: Keys;
}

interface GameContextType {
  gameState: GameState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
}

const GameContext = createContext<GameContextType | undefined>(undefined);

export const GameProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [gameState, setGameState] = useState<GameState>({
    position: { x: -180, y: -250 },
    isWalking: false,
    keys: { w: false, a: false, s: false, d: false }
  });

  return (
    <GameContext.Provider value={{ gameState, setGameState }}>
      {children}
    </GameContext.Provider>
  );
};

export const useGame = () => {
  const context = useContext(GameContext);
  if (context === undefined) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\game\useAnimation.ts
================================================================================
import { useState, useEffect, useRef } from 'react';
import { ANIMATION_CONFIG } from '../../constants';

export const useAnimation = (isWalking: boolean) => {
  const [currentFrame, setCurrentFrame] = useState(0);
  const animationTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    if (isWalking) {
      animationTimer.current = setInterval(() => {
        setCurrentFrame(prev => (prev + 1) % ANIMATION_CONFIG.WALK.FRAMES.length);
      }, ANIMATION_CONFIG.WALK.FRAME_DURATION);
    } else {
      setCurrentFrame(0);
    }

    return () => {
      if (animationTimer.current) {
        clearInterval(animationTimer.current);
        animationTimer.current = null;
      }
    };
  }, [isWalking]);

  const getCurrentFrame = () => {
    if (!isWalking) {
      return 0;
    }
    return ANIMATION_CONFIG.WALK.FRAMES[currentFrame];
  };

  return { currentFrame: getCurrentFrame() };
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\game\useCamera.ts
================================================================================
import { useState, useEffect, useRef } from 'react';
import type { Velocity } from '../../types';
import { CAMERA_CONFIG, PHYSICS } from '../../constants';

export const useCamera = () => {
  const [zoom, setZoom] = useState<number>(CAMERA_CONFIG.BASE_ZOOM);
  const zoomRef = useRef(zoom);

  useEffect(() => {
    zoomRef.current = zoom;
  }, [zoom]);

  const updateCamera = (velocity: Velocity) => {
    const currentSpeed = Math.sqrt(velocity.x ** 2 + velocity.y ** 2);
    const targetZoom = CAMERA_CONFIG.BASE_ZOOM + 
      (currentSpeed / PHYSICS.MAX_SPEED) * (CAMERA_CONFIG.MAX_ZOOM - CAMERA_CONFIG.BASE_ZOOM);
    
    setZoom(prevZoom => {
      const zoomDiff = targetZoom - prevZoom;
      return prevZoom + zoomDiff * CAMERA_CONFIG.ZOOM_SPEED;
    });
  };

  return { zoom, updateCamera };
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\game\useCollisionSystem.ts
================================================================================
import { useState, useEffect, useRef } from 'react';
import type { CollisionSystem } from '../../types';
import { GAME_CONFIG, ASSET_PATHS } from '../../constants';

export const useCollisionSystem = (): CollisionSystem => {
  const collisionCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const collisionContextRef = useRef<CanvasRenderingContext2D | null>(null);
  const maskImageRef = useRef<HTMLImageElement | null>(null);
  const [isLoaded, setIsLoaded] = useState(false);
  const backgroundSizeRef = useRef({ width: 0, height: 0 });

  const checkCollision = (x: number, y: number): boolean => {
    if (!collisionContextRef.current || !isLoaded) {
      return false;
    }

    try {
      const maskWidth = collisionCanvasRef.current?.width || 0;
      const maskHeight = collisionCanvasRef.current?.height || 0;
      const bgWidth = backgroundSizeRef.current.width;
      const bgHeight = backgroundSizeRef.current.height;
      
      if (maskWidth === 0 || maskHeight === 0 || bgWidth === 0 || bgHeight === 0) {
        return false;
      }
      
      const shadowCenterWorldX = GAME_CONFIG.WIDTH / 2;
      const shadowCenterWorldY = GAME_CONFIG.HEIGHT / 2 + GAME_CONFIG.CHARACTER.HEIGHT / 2 - 10;
      const bgX = shadowCenterWorldX - x;
      const bgY = shadowCenterWorldY - y;
      const scaleX = maskWidth / bgWidth;
      const scaleY = maskHeight / bgHeight;
      const maskX = Math.floor(bgX * scaleX);
      const maskY = Math.floor(bgY * scaleY);
      
      if (maskX >= 0 && maskX < maskWidth && maskY >= 0 && maskY < maskHeight) {
        const pixelData = collisionContextRef.current.getImageData(maskX, maskY, 1, 1).data;
        const [r, g, b] = pixelData;
        const isWhite = r === 255 && g === 255 && b === 255;
        return !isWhite;
      } else {
        return true;
      }
    } catch (error) {
      return false;
    }
  };

  useEffect(() => {
    const loadMask = () => {
      const maskImage = new Image();
      maskImageRef.current = maskImage;
      maskImage.onload = () => {
        const maskWidth = maskImage.naturalWidth;
        const maskHeight = maskImage.naturalHeight;
        const canvas = document.createElement('canvas');
        canvas.width = maskWidth;
        canvas.height = maskHeight;
        collisionCanvasRef.current = canvas;
        const context = canvas.getContext('2d');
        
        if (!context) return;
        
        collisionContextRef.current = context;
        collisionContextRef.current.drawImage(maskImage, 0, 0, maskWidth, maskHeight);
        setIsLoaded(true);
      };
      maskImage.src = ASSET_PATHS.BACKGROUND_MASK;
    };

    const bgImage = new Image();
    bgImage.onload = () => {
      backgroundSizeRef.current = {
        width: bgImage.naturalWidth,
        height: bgImage.naturalHeight
      };
      loadMask();
    };
    bgImage.src = ASSET_PATHS.BACKGROUND;
  }, []);

  return { checkCollision, isLoaded };
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\game\useGameLoop.ts
================================================================================
import { useEffect, useRef } from 'react';
import type { Position, Velocity, Keys } from '../../types';
import { PHYSICS, GAME_CONFIG } from '../../constants';

interface GameLoopProps {
  keys: Keys;
  onUpdate: (position: Position, velocity: Velocity, isMoving: boolean) => void;
  checkCollision: (x: number, y: number) => boolean;
}

export const useGameLoop = ({ keys, onUpdate, checkCollision }: GameLoopProps) => {
  const animationFrameId = useRef<number | null>(null);
  const gameLoopRunning = useRef(false);
  const velocity = useRef<Velocity>({ x: 0, y: 0 });
  const position = useRef<Position>({ 
    x: GAME_CONFIG.BACKGROUND.INITIAL_X, 
    y: GAME_CONFIG.BACKGROUND.INITIAL_Y 
  });

  useEffect(() => {
    const gameLoop = () => {
      if (!gameLoopRunning.current) return;

      let targetVelocityX = 0;
      let targetVelocityY = 0;
      
      if (keys.d) targetVelocityX = -PHYSICS.MAX_SPEED;
      if (keys.a) targetVelocityX = PHYSICS.MAX_SPEED;
      if (keys.s) targetVelocityY = -PHYSICS.MAX_SPEED;
      if (keys.w) targetVelocityY = PHYSICS.MAX_SPEED;

      if (targetVelocityX !== 0) {
        if (Math.abs(velocity.current.x) < Math.abs(targetVelocityX)) {
          velocity.current.x += Math.sign(targetVelocityX) * PHYSICS.ACCELERATION;
        }
      } else {
        if (velocity.current.x > 0) {
          velocity.current.x = Math.max(0, velocity.current.x - PHYSICS.DECELERATION);
        } else if (velocity.current.x < 0) {
          velocity.current.x = Math.min(0, velocity.current.x + PHYSICS.DECELERATION);
        }
      }

      if (targetVelocityY !== 0) {
        if (Math.abs(velocity.current.y) < Math.abs(targetVelocityY)) {
          velocity.current.y += Math.sign(targetVelocityY) * PHYSICS.ACCELERATION;
        }
      } else {
        if (velocity.current.y > 0) {
          velocity.current.y = Math.max(0, velocity.current.y - PHYSICS.DECELERATION);
        } else if (velocity.current.y < 0) {
          velocity.current.y = Math.min(0, velocity.current.y + PHYSICS.DECELERATION);
        }
      }
      
      velocity.current.x = Math.max(-PHYSICS.MAX_SPEED, Math.min(PHYSICS.MAX_SPEED, velocity.current.x));
      velocity.current.y = Math.max(-PHYSICS.MAX_SPEED, Math.min(PHYSICS.MAX_SPEED, velocity.current.y));

      let newX = position.current.x;
      let newY = position.current.y;

      if (velocity.current.x !== 0) {
        const step = Math.sign(velocity.current.x);
        let testX = position.current.x;
        for (let i = 0; i < Math.abs(velocity.current.x); i++) {
          testX += step;
          if (checkCollision(testX, position.current.y)) {
            testX -= step;
            velocity.current.x = 0;
            break;
          }
        }
        newX = testX;
      }

      if (velocity.current.y !== 0) {
        const step = Math.sign(velocity.current.y);
        let testY = position.current.y;
        for (let i = 0; i < Math.abs(velocity.current.y); i++) {
          testY += step;
          if (checkCollision(newX, testY)) {
            testY -= step;
            velocity.current.y = 0;
            break;
          }
        }
        newY = testY;
      }

      position.current = { x: newX, y: newY };
      const isMoving = Math.abs(velocity.current.x) > 0.1 || Math.abs(velocity.current.y) > 0.1;
      
      onUpdate({ x: newX, y: newY }, velocity.current, isMoving);

      animationFrameId.current = requestAnimationFrame(gameLoop);
    };

    gameLoopRunning.current = true;
    animationFrameId.current = requestAnimationFrame(gameLoop);

    return () => {
      gameLoopRunning.current = false;
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
        animationFrameId.current = null;
      }
    };
  }, [keys, onUpdate, checkCollision]);

  return { velocity: velocity.current };
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\game\useGameScale.ts
================================================================================
import { useState, useEffect, useRef } from 'react';
import type { GameScale } from '../../types';
import { GAME_CONFIG } from '../../constants';

export const useGameScale = (): GameScale => {
  const [scale, setScale] = useState(1);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const updateScale = () => {
      if (containerRef.current) {
        const container = containerRef.current;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        
        if (containerWidth > 0 && containerHeight > 0) {
          const scaleX = containerWidth / GAME_CONFIG.WIDTH;
          const scaleY = containerHeight / GAME_CONFIG.HEIGHT;
          const newScale = Math.min(scaleX, scaleY);
          setScale(newScale);
        }
      }
    };

    updateScale();
    window.addEventListener('resize', updateScale);
    
    return () => window.removeEventListener('resize', updateScale);
  }, []);

  return { scale, containerRef: containerRef as React.RefObject<HTMLDivElement> };
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\game\useKeyboardControls.ts
================================================================================
import { useState, useEffect, useRef } from 'react';
import { useGame } from '../../contexts/GameContext';
import type { Keys } from '../../types';
import { KEY_MAPPINGS, PREVENT_DEFAULT_KEYS } from '../../constants';

export const useKeyboardControls = () => {
  const [direction, setDirection] = useState<'right' | 'left'>('right');
  const { setGameState } = useGame();
  const keysRef = useRef<Keys>({ w: false, a: false, s: false, d: false });

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (PREVENT_DEFAULT_KEYS.includes(event.key as any)) {
        event.preventDefault();
      }

      const key = event.key.toLowerCase();
      const newKeys = { ...keysRef.current };

      if (KEY_MAPPINGS.RIGHT.includes(key as any)) {
        newKeys.d = true;
        setDirection('right');
      } else if (KEY_MAPPINGS.LEFT.includes(key as any)) {
        newKeys.a = true;
        setDirection('left');
      } else if (KEY_MAPPINGS.DOWN.includes(key as any)) {
        newKeys.s = true;
        newKeys.w = false;
      } else if (KEY_MAPPINGS.UP.includes(key as any)) {
        newKeys.w = true;
        newKeys.s = false;
      }

      keysRef.current = newKeys;
      setGameState(prev => ({
        ...prev,
        keys: newKeys
      }));
    };

    const handleKeyUp = (event: KeyboardEvent) => {
      const key = event.key.toLowerCase();
      const newKeys = { ...keysRef.current };

      if (KEY_MAPPINGS.RIGHT.includes(key as any)) {
        newKeys.d = false;
      } else if (KEY_MAPPINGS.LEFT.includes(key as any)) {
        newKeys.a = false;
      } else if (KEY_MAPPINGS.DOWN.includes(key as any)) {
        newKeys.s = false;
      } else if (KEY_MAPPINGS.UP.includes(key as any)) {
        newKeys.w = false;
      }

      keysRef.current = newKeys;
      setGameState(prev => ({
        ...prev,
        keys: newKeys
      }));
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [setGameState]);

  return { 
    keys: keysRef.current, 
    direction, 
    setDirection 
  };
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\index.ts
================================================================================
export * from './game/useGameScale';
export * from './game/useKeyboardControls';
export * from './game/useCollisionSystem';
export * from './game/useAnimation';
export * from './game/useCamera';
export * from './game/useGameLoop';
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\objects\useInteractiveObject.ts
================================================================================
import { useState, useEffect } from 'react';
import { useGame } from '../../contexts/GameContext';

interface UseInteractiveObjectProps {
  objectId: string;
  position: { x: number; y: number };
  interactionRadius: number;
  onInteract: () => void;
}

export const useInteractiveObject = ({
  position,
  interactionRadius,
  onInteract
}: UseInteractiveObjectProps) => {
  const { gameState } = useGame();
  const [isNear, setIsNear] = useState(false);

  const objectWorldX = position.x;
  const objectWorldY = position.y;
  
  const characterWorldX = -gameState.position.x;
  const characterWorldY = -gameState.position.y;

  useEffect(() => {
    const distance = Math.sqrt(
      Math.pow(characterWorldX - objectWorldX, 2) + 
      Math.pow(characterWorldY - objectWorldY, 2)
    );
    setIsNear(distance < interactionRadius);
  }, [characterWorldX, characterWorldY, objectWorldX, objectWorldY, interactionRadius]);

  useEffect(() => {
    const handleInteraction = (event: KeyboardEvent) => {
      if (isNear && event.key === 'e') {
        onInteract();
      }
    };

    window.addEventListener('keydown', handleInteraction);
    return () => window.removeEventListener('keydown', handleInteraction);
  }, [isNear, onInteract]);

  return { 
    isNear, 
    canInteract: isNear 
  };
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\hooks\useSpriteManager.ts
================================================================================
import { useRef, useEffect, useState } from 'react';
import { ASSET_PATHS, ANIMATION_CONFIG } from '../constants';

export const useSpriteManager = () => {
  const sprites = useRef<Map<string, HTMLImageElement>>(new Map());
  const [loaded, setLoaded] = useState(false);
  const [loadingProgress, setLoadingProgress] = useState(0);

  useEffect(() => {
    const loadSprites = async () => {
      const spriteUrls = [
        { key: 'static', url: ASSET_PATHS.CHARACTER.STATIC },
        ...ANIMATION_CONFIG.WALK.FRAMES.map(frame => ({
          key: `frame_${frame}`,
          url: ASSET_PATHS.CHARACTER.FRAME(frame)
        }))
      ];

      let loadedCount = 0;
      
      await Promise.all(
        spriteUrls.map(({ key, url }) => 
          new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              sprites.current.set(key, img);
              loadedCount++;
              setLoadingProgress((loadedCount / spriteUrls.length) * 100);
              resolve(null);
            };
            img.onerror = reject;
            img.src = url;
          })
        )
      );

      setLoaded(true);
    };

    loadSprites();
  }, []);

  const getSprite = (key: string): HTMLImageElement | undefined => {
    return sprites.current.get(key);
  };

  return { 
    loaded,
    loadingProgress,
    getSprite,
    getStaticSprite: () => getSprite('static'),
    getWalkSprite: (frame: number) => getSprite(`frame_${frame}`)
  };
};
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\types\game.ts
================================================================================
export interface Position {
  x: number;
  y: number;
}

export interface Velocity {
  x: number;
  y: number;
}

export interface Keys {
  w: boolean;
  a: boolean;
  s: boolean;
  d: boolean;
}

export type Direction = 'left' | 'right';

export interface CharacterState {
  position: Position;
  velocity: Velocity;
  direction: Direction;
  isWalking: boolean;
  currentFrame: number;
}

export interface GameScale {
  scale: number;
  containerRef: React.RefObject<HTMLDivElement>;
}

export interface CollisionSystem {
  checkCollision: (x: number, y: number) => boolean;
  isLoaded: boolean;
}

export interface AnimationConfig {
  frames: number[];
  frameDuration: number;
  loop: boolean;
}
--------------------------------------------------------------------------------

–§–∞–π–ª: C:\Users\–î–æ–º\Desktop\web –∫—É—Ä—Å –≤—à—ç\project\my-react-app\src\types\index.ts
================================================================================
export * from './game';
--------------------------------------------------------------------------------

